import MLXArray, { array, zeros, zeros_like, ones, ones_like, full, type ArrayElement } from './array';
import dtypeModule, { Dtype, fromString as dtypeFromString, keys as dtypeKeys, values as dtypeValues, items as dtypeItems, dir as dtypeDir, has as dtypeHas, get as dtypeGet, issubdtype as dtypeIssubdtype, categoryKeys as dtypeCategoryKeys, categoryValues as dtypeCategoryValues, categoryItems as dtypeCategoryItems, bool, int8, int16, int32, int64, uint8, uint16, uint32, uint64, float16, bfloat16, float32, float64, complex64, complexfloating, floating, inexact, signedinteger, unsignedinteger, integer, number, generic, type MLXDtype, type DTypeKey, type DTypeCategory, type DTypeCategoryKey, type DTypeLike } from './dtype';
import * as deviceModule from './device';
import { MLXStream, defaultStream, newStream, setDefaultStream, synchronize, streamContext, withStream } from './stream';
import { reshape, transpose, moveaxis, swapaxes, add, multiply, where } from './ops';
export type { ArrayElement, DTypeKey, DTypeCategoryKey, DTypeCategory, DTypeLike, MLXDtype, };
export type { Device, DeviceLike } from './device';
export type { StreamLike } from './stream';
export type { ReshapeOptions, TransposeOptions, MoveAxisOptions, SwapAxesOptions, BinaryOpOptions, WhereOptions, } from './ops';
export { MLXArray, MLXArray as Array, array };
export { zeros, zeros_like, ones, ones_like, full };
export { deviceModule as device };
export { MLXStream as Stream, defaultStream, newStream, setDefaultStream, synchronize, streamContext, streamContext as stream, withStream, };
export { reshape, transpose, moveaxis, swapaxes, add, multiply, where };
export { dtypeModule as dtype, Dtype, dtypeFromString, dtypeKeys, dtypeValues, dtypeItems, dtypeDir, dtypeHas, dtypeGet, dtypeCategoryKeys, dtypeCategoryValues, dtypeCategoryItems, dtypeIssubdtype as issubdtype, bool, int8, int16, int32, int64, uint8, uint16, uint32, uint64, float16, bfloat16, float32, float64, complex64, complexfloating, floating, inexact, signedinteger, unsignedinteger, integer, number, generic, };
declare const core: {
    array: typeof array;
    zeros: typeof zeros;
    zeros_like: typeof zeros_like;
    ones: typeof ones;
    ones_like: typeof ones_like;
    full: typeof full;
    Array: typeof MLXArray;
    Stream: typeof MLXStream;
    defaultStream: typeof defaultStream;
    newStream: typeof newStream;
    setDefaultStream: typeof setDefaultStream;
    synchronize: typeof synchronize;
    streamContext: typeof streamContext;
    stream: typeof streamContext;
    withStream: typeof withStream;
    reshape: typeof reshape;
    transpose: typeof transpose;
    moveaxis: typeof moveaxis;
    swapaxes: typeof swapaxes;
    add: typeof add;
    multiply: typeof multiply;
    where: typeof where;
    device: typeof deviceModule;
    Dtype: {
        fromString(key: string): MLXDtype;
    };
    dtype: {
        complexfloating: DTypeCategory;
        floating: DTypeCategory;
        inexact: DTypeCategory;
        signedinteger: DTypeCategory;
        unsignedinteger: DTypeCategory;
        integer: DTypeCategory;
        number: DTypeCategory;
        generic: DTypeCategory;
        bool: MLXDtype;
        int8: MLXDtype;
        int16: MLXDtype;
        int32: MLXDtype;
        int64: MLXDtype;
        uint8: MLXDtype;
        uint16: MLXDtype;
        uint32: MLXDtype;
        uint64: MLXDtype;
        float16: MLXDtype;
        bfloat16: MLXDtype;
        float32: MLXDtype;
        float64: MLXDtype;
        complex64: MLXDtype;
        Dtype: {
            fromString(key: string): MLXDtype;
        };
        fromString: (key: DTypeKey) => MLXDtype;
        keys: () => DTypeKey[];
        values: () => MLXDtype[];
        items: () => Array<[DTypeKey, MLXDtype]>;
        dir: () => string[];
        has: (key: string) => key is DTypeKey;
        get: (key: DTypeKey) => MLXDtype;
        issubdtype: (a: DTypeLike, b: DTypeLike) => boolean;
        categoryKeys: () => DTypeCategoryKey[];
        categoryValues: () => DTypeCategory[];
        categoryItems: () => Array<[DTypeCategoryKey, DTypeCategory]>;
    };
    dtypeFromString: (key: DTypeKey) => MLXDtype;
    dtypeKeys: () => DTypeKey[];
    dtypeValues: () => MLXDtype[];
    dtypeItems: () => Array<[DTypeKey, MLXDtype]>;
    dtypeDir: () => string[];
    dtypeHas: (key: string) => key is DTypeKey;
    dtypeGet: (key: DTypeKey) => MLXDtype;
    dtypeCategoryKeys: () => DTypeCategoryKey[];
    dtypeCategoryValues: () => DTypeCategory[];
    dtypeCategoryItems: () => Array<[DTypeCategoryKey, DTypeCategory]>;
    issubdtype: (a: DTypeLike, b: DTypeLike) => boolean;
    bool: MLXDtype;
    int8: MLXDtype;
    int16: MLXDtype;
    int32: MLXDtype;
    int64: MLXDtype;
    uint8: MLXDtype;
    uint16: MLXDtype;
    uint32: MLXDtype;
    uint64: MLXDtype;
    float16: MLXDtype;
    bfloat16: MLXDtype;
    float32: MLXDtype;
    float64: MLXDtype;
    complex64: MLXDtype;
    complexfloating: DTypeCategory;
    floating: DTypeCategory;
    inexact: DTypeCategory;
    signedinteger: DTypeCategory;
    unsignedinteger: DTypeCategory;
    integer: DTypeCategory;
    number: DTypeCategory;
    generic: DTypeCategory;
};
export default core;
